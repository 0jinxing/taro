<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.68">
<link rel="search" type="application/opensearchdescription+xml" title="Taro 文档" href="/taro/opensearch.xml">
<script src="https://storage.jd.com/taro-resource/tongji.js" async></script>
<script src="https://storage.jd.com/taro-docs/taro-doc-hotjar.js" async></script><title data-react-helmet="true">Taro Next H5 跨框架组件库实践 | Taro 文档</title><meta data-react-helmet="true" property="og:title" content="Taro Next H5 跨框架组件库实践 | Taro 文档"><meta data-react-helmet="true" name="description" content="image"><meta data-react-helmet="true" property="og:description" content="image"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="default"><link data-react-helmet="true" rel="shortcut icon" href="/taro/./img/favicon.ico"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/taro/styles.aced0b20.css">
<link rel="preload" href="/taro/styles.55db6f27.js" as="script">
<link rel="preload" href="/taro/runtime~main.452067a7.js" as="script">
<link rel="preload" href="/taro/main.741ca0ab.js" as="script">
<link rel="preload" href="/taro/1.8febc1d6.js" as="script">
<link rel="preload" href="/taro/2.caae0f6a.js" as="script">
<link rel="preload" href="/taro/01a85c17.d4a75056.js" as="script">
<link rel="preload" href="/taro/18b93cb3.536e509c.js" as="script">
<link rel="preload" href="/taro/1669.ecc950a7.js" as="script">
<link rel="preload" href="/taro/5fc994c2.595b4ed3.js" as="script">
<link rel="preload" href="/taro/6875c492.f9b5f9a7.js" as="script">
<link rel="preload" href="/taro/a6aa9e1f.3e03078a.js" as="script">
<link rel="preload" href="/taro/c42b0552.bf4bc072.js" as="script">
<link rel="preload" href="/taro/ccc49370.da0c6a17.js" as="script">
<link rel="preload" href="/taro/75e89b51.e14eadb4.js" as="script">
<link rel="preload" href="/taro/3e821025.17008bdb.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_2AhQ">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/taro/"><img src="/taro/img/logo-taro.png" alt="Taro logo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Taro logo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Taro</strong></a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link" href="/taro/docs/README">3.x</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/taro/docs/next/README">下个版本</a></li><li><a class="dropdown__link" href="/taro/docs/README">3.x</a></li><li><a class="dropdown__link" href="/taro/docs/2.x/README">2.x</a></li><li><a class="dropdown__link" href="/taro/docs/1.x/README">1.x</a></li><li><a class="dropdown__link" href="/taro/versions">全部版本</a></li></ul></div><a class="navbar__item navbar__link" href="/taro/docs/README">文档</a><a class="navbar__item navbar__link" href="/taro/docs/components-desc">组件库</a><a class="navbar__item navbar__link" href="/taro/docs/apis/about/desc">API</a><a class="navbar__item navbar__link" href="/taro/docs/guide">教程</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/taro/blog">博客</a><a class="navbar__item navbar__link" href="/taro/showcase">案例</a></div><div class="navbar__items navbar__items--right"><a href="https://taro-ui.jd.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Taro UI</a><a href="https://taro-ext.jd.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">物料市场</a><a href="https://taro-club.jd.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">论坛</a><a href="https://taro.jd.com/jdmp/index.html" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">京东小程序</a><a href="https://github.com/nervjs/taro" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span><span class="DocSearch-Button-Key">⌘</span><span class="DocSearch-Button-Key">K</span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/taro/"><img src="/taro/img/logo-taro.png" alt="Taro logo" class="themedImage_2E_h themedImage--light_AouX navbar__logo"><img alt="Taro logo" class="themedImage_2E_h themedImage--dark_1YPN navbar__logo"><strong class="navbar__title">Taro</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">Versions</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/taro/docs/next/README">下个版本</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/docs/README">3.x</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/docs/2.x/README">2.x</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/docs/1.x/README">1.x</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/versions">全部版本</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/taro/docs/README">文档</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/docs/components-desc">组件库</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/docs/apis/about/desc">API</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/docs/guide">教程</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/taro/blog">博客</a></li><li class="menu__list-item"><a class="menu__link" href="/taro/showcase">案例</a></li><li class="menu__list-item"><a href="https://taro-ui.jd.com" target="_blank" rel="noopener noreferrer" class="menu__link">Taro UI</a></li><li class="menu__list-item"><a href="https://taro-ext.jd.com" target="_blank" rel="noopener noreferrer" class="menu__link">物料市场</a></li><li class="menu__list-item"><a href="https://taro-club.jd.com" target="_blank" rel="noopener noreferrer" class="menu__link">论坛</a></li><li class="menu__list-item"><a href="https://taro.jd.com/jdmp/index.html" target="_blank" rel="noopener noreferrer" class="menu__link">京东小程序</a></li><li class="menu__list-item"><a href="https://github.com/nervjs/taro" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link" aria-label="GitHub repository"></a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--2"><div class="sidebar_3I7I thin-scrollbar"><h3 class="sidebarItemTitle_2Dv3">最近更新</h3><ul class="sidebarItemList_1RlG"><li class="sidebarItem_Hxgp"><a class="sidebarItemLink_3ppv" href="/taro/blog/2020-09-01-taro-versions">Taro 版本升级权威指南</a></li><li class="sidebarItem_Hxgp"><a class="sidebarItemLink_3ppv" href="/taro/blog/2020-07-01-taro-3-0-0">Taro 3 正式版发布：开放式跨端跨框架解决方案</a></li><li class="sidebarItem_Hxgp"><a class="sidebarItemLink_3ppv" href="/taro/blog/2020-05-26-taro-3-rc">Taro 3.0 RC：React/Vue/Nerv 任你选</a></li><li class="sidebarItem_Hxgp"><a class="sidebarItemLink_3ppv" href="/taro/blog/2020-04-27-taro-build-jd">使用 Taro 快速开发京东小程序</a></li><li class="sidebarItem_Hxgp"><a class="sidebarItemLink_3ppv" href="/taro/blog/2020-04-27-taro-vs-jd">京东小程序 Taro 开发对比原生开发测评</a></li></ul></div></div><main class="col col--8"><article><header><h1 class="margin-bottom--sm blogPostTitle_1mse">Taro Next H5 跨框架组件库实践</h1><div class="margin-vert--md"><time datetime="2020-04-13T00:00:00.000Z" class="blogPostDate_3bQP">April 13, 2020  · 7 min read</time></div><div class="avatar margin-vert--md"><a class="avatar__photo-link avatar__photo" href="https://github.com/Chen-jj" target="_blank" rel="noreferrer noopener"><img src="https://storage.jd.com/cjj-pub-images/11807297.png" alt="JJ"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/Chen-jj" target="_blank" rel="noreferrer noopener">JJ</a></h4><small class="avatar__subtitle"></small></div></div></header><section class="markdown"><p><img src="https://img30.360buyimg.com/ling/jfs/t1/108543/10/12151/1750297/5e93ef97Ef424d4a7/29cf4e4364e5d3f0.png" alt="image"></p><p><a href="https://github.com/NervJS/taro">Taro</a> 是一款多端开发框架。开发者只需编写一份代码，即可生成各小程序端、H5 以及 React Native 的应用。</p><blockquote><p><a href="https://docs.taro.zone/taro/docs/README.html">Taro Next</a> 近期已发布 beta 版本，全面完善对小程序以及 H5 的支持，欢迎体验！</p></blockquote><p>本文将重点介绍对 <strong>Taro H5 端组件库</strong>的改造工作。</p><h2 id="背景">背景</h2><h3 id="taro-next-将支持使用多框架开发">Taro Next 将支持使用多框架开发</h3><p>过去的 Taro 1 与 Taro 2 只能使用 React 语法进行开发，但下一代的 Taro 框架对整体架构进行了<a href="https://aotu.io/notes/2020/02/03/taro-next-alpha/">升级</a>，支持使用 React、Vue、Nerv 等框架开发多端应用。</p><p>为了支持使用多框架进行开发，Taro 需要对自身的各端适配能力进行改造。本文将重点介绍对 <strong>Taro H5 端组件库</strong>的改造工作。</p><h3 id="taro-h5">Taro H5</h3><p>Taro 遵循以微信小程序为主，其他小程序为辅的组件与 API 规范。</p><p>但浏览器并没有小程序规范的组件与 API 可供使用，例如我们不能在浏览器上使用小程序的 <code>view</code> 组件和 <code>getSystemInfo</code>  API。因此我们需要在 H5 端实现一套基于小程序规范的组件库和 API 库。</p><blockquote><p>Taro H5 架构图：</p></blockquote><p><img src="https://storage.jd.com/cjj-pub-images/WX20200402-140148.png"></p><p>在 Taro 1 和 Taro 2 中，Taro H5 的组件库使用了 React 语法进行开发。但如果开发者在 Taro Next 中使用 Vue 开发 H5 应用，则不能和现有的 H5 组件库兼容。</p><p>所以本文需要面对的核心问题就是：<strong>我们需要在 H5 端实现 React、Vue 等框架都可以使用的组件库</strong>。</p><h3 id="方案选择">方案选择</h3><p>我们最先想到的是使用 Vue 再开发一套组件库，这样最为稳妥，工作量也没有特别大。</p><p>但考虑到以下两点，我们遂放弃了此思路：</p><ol><li>组件库的可维护性和拓展性不足。每当有问题需要修复或新功能需要添加，我们需要分别对 React 和 Vue 版本的组件库进行改造。</li><li>Taro Next 的目标是支持使用任意框架开发多端应用。倘若将来支持使用 Angular 等框架进行开发，那么我们需要再开发对应支持 Angular 等框架的组件库。</li></ol><p>那么是否存在着一种方案，使得只用一份代码构建的组件库能兼容所有的 web 开发框架呢？</p><p>答案就是 <strong>Web Components</strong>。</p><p>但在组件库改造为 Web Components 的过程并不是一凡风顺的，我们也遇到了不少的问题，故借此文向大家娓娓道来。</p><h2 id="web-components-简介">Web Components 简介</h2><p><a href="https://www.webcomponents.org/introduction">Web Components</a> 由一系列的技术规范所组成，它让开发者可以开发出浏览器原生支持的组件。</p><h3 id="技术规范">技术规范</h3><p>Web Components 的主要技术规范为：</p><ul><li>Custom Elements</li><li>Shadow DOM</li><li>HTML Template</li></ul><p>Custom Elements 让开发者可以自定义带有特定行为的 HTML 标签。</p><p>Shadow DOM 对标签内的结构和样式进行一层包装。</p><p><code>&lt;template&gt;</code> 标签为 Web Components 提供复用性，还可以配合 <code>&lt;slot&gt;</code> 标签提供灵活性。</p><h3 id="示例">示例</h3><p>定义模板：</p><pre><code class="language-html">&lt;template id=&quot;template&quot;&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;/template&gt;
</code></pre><p>构造 Custom Element：</p><pre><code class="language-js">class App extends HTMLElement {
  constructor () {
    super(...arguments)

    // 开启 Shadow DOM
    const shadowRoot = this.attachShadow({ mode: &#x27;open&#x27; })

    // 复用 &lt;template&gt; 定义好的结构 
    const template = document.querySelector(&#x27;#template&#x27;)
    const node = template.content.cloneNode(true)
    shadowRoot.appendChild(node)
  }
}
window.customElements.define(&#x27;my-app&#x27;, App)
</code></pre><p>使用：</p><pre><code class="language-html">&lt;my-app&gt;&lt;/my-app&gt;
</code></pre><h2 id="stencil">Stencil</h2><p>使用原生语法去编写 Web Components 相当繁琐，因此我们需要一个框架帮助我们提高开发效率和开发体验。</p><p>业界已经有很多成熟的 <a href="https://www.webcomponents.org/libraries">Web Components 框架</a>，一番比较后我们最终选择了 <a href="https://stenciljs.com/docs/introduction">Stencil</a>，原因有二：</p><ol><li>Stencil 由 Ionic 团队打造，被用于构建 Ionic 的组件库，证明经受过业界考验。</li><li>Stencil 支持 JSX，能减少现有组件库的迁移成本。</li></ol><p>Stencil 是一个可以生成 Web Components 的编译器。它糅合了业界前端框架的一些优秀概念，如支持 Typescript、JSX、虚拟 DOM 等。</p><h3 id="示例：">示例：</h3><p>创建 Stencil Component：</p><pre><code class="language-jsx">import { Component, Prop, State, h } from &#x27;@stencil/core&#x27;

@Component({
  tag: &#x27;my-component&#x27;
})
export class MyComponent {
  @Prop() first = &#x27;&#x27;
  @State() last = &#x27;JS&#x27;

  componentDidLoad () {
    console.log(&#x27;load&#x27;)
  }

  render () {
    return (
      &lt;div&gt;
        Hello, my name is {this.first} {this.last}
      &lt;/div&gt;
    )
  }
}
</code></pre><p>使用组件：</p><pre><code class="language-html">&lt;my-component first=&#x27;Taro&#x27; /&gt;
</code></pre><h2 id="在-react-与-vue-中使用-stencil">在 React 与 Vue 中使用 Stencil</h2><p>到目前为止一切都那么美好：使用 Stencil 编写出 Web Components，即可以在 React 和 Vue 中直接使用它们。</p><p>但实际使用上却会出现一些问题，<a href="https://custom-elements-everywhere.com/">Custom Elements Everywhere</a> 通过一系列的测试用例，罗列出业界前端框架对 Web Components 的兼容问题及相关 issues。下面将简单介绍 Taro H5 组件库分别对 React 和 Vue 的兼容工作。</p><h3 id="兼容-react">兼容 React</h3><h4 id="1-props">1. Props</h4><h5 id="11-问题">1.1 问题</h5><p>React 使用 <code>setAttribute</code> 的形式给 Web Components 传递参数。当参数为原始类型时是可以运行的，但是如果参数为对象或数组时，由于 HTML 元素的 attribute 值只能为字符串或 null，最终给 WebComponents 设置的 attribute 会是 <code>attr=&quot;[object Object]&quot;</code>。</p><blockquote><p>attribute 与 property <a href="https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html#answer-6004028">区别</a></p></blockquote><h5 id="12-解决方案">1.2 解决方案</h5><p>采用 <strong>DOM Property</strong> 的方法传参。</p><p>我们可以把 Web Components 包装一层高阶组件，把高阶组件上的 props 设置为 Web Components 的 property：</p><pre><code class="language-js">const reactifyWebComponent = WC =&gt; {
  return class extends React.Component {
    ref = React.createRef()

    update () {
      Object.entries(this.props).forEach(([prop, val]) =&gt; {
        if (prop === &#x27;children&#x27; || prop === &#x27;dangerouslySetInnerHTML&#x27;) {
          return
        }
        if (prop === &#x27;style&#x27; &amp;&amp; val &amp;&amp; typeof val === &#x27;object&#x27;) {
          for (const key in val) {
            this.ref.current.style[key] = val[key]
          }
          return
        }
        this.ref.current[prop] = val
      })
    }

    componentDidUpdate () {
      this.update()
    }

    componentDidMount () {
      this.update()
    }

    render () {
      const { children, dangerouslySetInnerHTML } = this.props
      return React.createElement(WC, {
        ref: this.ref,
        dangerouslySetInnerHTML
      }, children)
    }
  }
}

const MyComponent = reactifyWebComponent(&#x27;my-component&#x27;)
</code></pre><p>注意：</p><ul><li>children、dangerouslySetInnerHTML 属性需要透传。</li><li>React 中 style 属性值可以接受对象形式，这里需要额外处理。</li></ul><h4 id="2-events">2. Events</h4><h5 id="21-问题">2.1 问题</h5><p>因为 React 有一套<a href="https://reactjs.org/docs/events.html">合成事件系统</a>，所以它不能监听到 Web Components 发出的自定义事件。</p><p>以下 Web Component 的 onLongPress 回调不会被触发：</p><pre><code class="language-html">&lt;my-view onLongPress={onLongPress}&gt;view&lt;/my-view&gt;
</code></pre><h5 id="22-解决方案">2.2 解决方案</h5><p>通过 ref 取得 Web Component 元素，手动 <strong>addEventListener</strong> 绑定事件。</p><p>改造上述的高阶组件：</p><pre><code class="language-js">const reactifyWebComponent = WC =&gt; {
  return class Index extends React.Component {
    ref = React.createRef()
    eventHandlers = []

    update () {
      this.clearEventHandlers()

      Object.entries(this.props).forEach(([prop, val]) =&gt; {
        if (typeof val === &#x27;function&#x27; &amp;&amp; prop.match(/^on[A-Z]/)) {
          const event = prop.substr(2).toLowerCase()
          this.eventHandlers.push([event, val])
          return this.ref.current.addEventListener(event, val)
        }

        ...
      })
    }

    clearEventHandlers () {
      this.eventHandlers.forEach(([event, handler]) =&gt; {
        this.ref.current.removeEventListener(event, handler)
      })
      this.eventHandlers = []
    }

    componentWillUnmount () {
      this.clearEventHandlers()
    }
    
    ...
  }
}
</code></pre><h4 id="3-ref">3. Ref</h4><h5 id="31-问题">3.1 问题</h5><p>我们为了解决 Props 和 Events 的问题，引入了高阶组件。那么当开发者向高阶组件传入 ref 时，获取到的其实是高阶组件，但我们希望开发者能获取到对应的 Web Component。</p><p>domRef 会获取到 <code>MyComponent</code>，而不是 <code>&lt;my-component&gt;&lt;/my-component&gt;</code></p><pre><code class="language-jsx">&lt;MyComponent ref={domRef} /&gt;
</code></pre><h5 id="32-解决方案">3.2 解决方案</h5><p>使用 <a href="https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">forwardRef</a> 传递 ref。</p><p>改造上述的高阶组件为 forwardRef 形式：</p><pre><code class="language-js">const reactifyWebComponent = WC =&gt; {
  class Index extends React.Component {
    ...
    
    render () {
      const { children, forwardRef } = this.props
      return React.createElement(WC, {
        ref: forwardRef
      }, children)
    }
  }
  return React.forwardRef((props, ref) =&gt; (
    React.createElement(Index, { ...props, forwardRef: ref })
  ))
}
</code></pre><h4 id="4-hosts-classname">4. Host&#x27;s className</h4><h5 id="41-问题">4.1 问题</h5><p>在 Stencil 里我们可以使用 Host 组件为 host element 添加类名。</p><pre><code class="language-js">import { Component, Host, h } from &#x27;@stencil/core&#x27;;

@Component({
  tag: &#x27;todo-list&#x27;
})
export class TodoList {
  render () {
    return (
      &lt;Host class=&#x27;todo-list&#x27;&gt;
        &lt;div&gt;todo&lt;/div&gt;
      &lt;/Host&gt;
    )
  }
}
</code></pre><p>然后在使用 <code>&lt;todo-list&gt;</code> 元素时会展示我们内置的类名 “todo-list” 和 Stencil 自动加入的类名 “hydrated”：</p><p><img src="https://storage.jd.com/cjj-pub-images/WX20200401-102833.png"></p><p>但如果我们在使用时设置了动态类名，如： <code>&lt;todo-list class={this.state.cls}&gt;</code>。那么在动态类名更新时，则会把内置的类名 “todo-list” 和 “hydrated” 抹除掉。</p><p><strong>关于类名 “hydrated”：</strong></p><p>Stencil 会为所有 Web Components 加上 <code>visibility: hidden;</code> 的样式。然后在各 Web Component 初始化完成后加入类名 “hydrated”，将 <code>visibility</code> 改为 <code>inherit</code>。如果 “hydrated” 被抹除掉，Web Components 将不可见。</p><p>因此我们需要保证在类名更新时不会覆盖 Web Components 的内置类名。</p><h5 id="42-解决方案">4.2 解决方案</h5><p>高阶组件在使用 ref 为 Web Component 设置 className 属性时，对内置 class 进行合并。</p><p>改造上述的高阶组件：</p><pre><code class="language-js">const reactifyWebComponent = WC =&gt; {
  class Index extends React.Component {
    update (prevProps) {
      Object.entries(this.props).forEach(([prop, val]) =&gt; {
        if (prop.toLowerCase() === &#x27;classname&#x27;) {
          this.ref.current.className = prevProps
            // getClassName 在保留内置类名的情况下，返回最新的类名
            ? getClassName(this.ref.current, prevProps, this.props)
            : val
          return
        }

        ...
      })
    }

    componentDidUpdate (prevProps) {
      this.update(prevProps)
    }

    componentDidMount () {
      this.update()
    }

    ...
  }
  return React.forwardRef((props, ref) =&gt; (
    React.createElement(Index, { ...props, forwardRef: ref })
  ))
}
</code></pre><h3 id="兼容-vue">兼容 Vue</h3><p>不同于 React，虽然 Vue 在传递参数给 Web Components 时也是采用 <code>setAttribute</code> 的方式，但 v-bind 指令提供了 <a href="https://cn.vuejs.org/v2/api/#v-bind">.prop</a> 修饰符，它可以将参数作为 DOM property 来绑定。另外 Vue 也能监听 Web Components 发出的自定义事件。</p><p>因此 Vue 在 Props 和 Events 两个问题上都不需要额外处理，但在与 Stencil 的配合上还是有一些兼容问题，接下来将列出主要的三点。</p><h4 id="1-hosts-classname">1. Host&#x27;s className</h4><h5 id="11-问题-1">1.1 问题</h5><p>同上文兼容 React 第四部分，在 Vue 中更新 host element 的 class，也会覆盖内置 class。</p><h5 id="12-解决方案-1">1.2 解决方案</h5><p>同样的思路，需要在 Web Components 上包装一层 Vue 的自定义组件。</p><pre><code class="language-js">function createComponent (name, classNames = []) {
  return {
    name,
    computed: {
      listeners () {
        return { ...this.$listeners }
      }
    },
    render (createElement) {
      return createElement(name, {
        class: [&#x27;hydrated&#x27;, ...classNames],
        on: this.listeners
      }, this.$slots.default)
    }
  }
}

Vue.component(&#x27;todo-list&#x27;, createComponent(&#x27;todo-list&#x27;, [&#x27;todo-list&#x27;]))
</code></pre><p>注意：</p><ul><li>我们在自定义组件中重复声明了 Web Component 该有的内置类名。后续开发者为自定义组件设置类名时，Vue 将会<a href="https://cn.vuejs.org/v2/guide/components-props.html#%E6%9B%BF%E6%8D%A2-%E5%90%88%E5%B9%B6%E5%B7%B2%E6%9C%89%E7%9A%84-Attribute">自动对类名进行合并</a>。</li><li>需要把自定义组件上绑定的事件通过 <a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6">$listeners</a> 透传给 Web Component。</li></ul><h4 id="2-ref">2. Ref</h4><h5 id="21-问题-1">2.1 问题</h5><p>为了解决问题 1，我们给 Vue 中的 Web Components 都包装了一层自定义组件。同样地，开发者在使用 ref 时取到的是自定义组件，而不是 Web Component。</p><h5 id="22-解决方案-1">2.2 解决方案</h5><p>Vue 并没有 forwardRef 的概念，只可简单粗暴地修改 <code>this.$parent.$refs</code>。</p><p>为自定义组件增加一个 mixin：</p><pre><code class="language-js">export const refs = {
  mounted () {
    if (Object.keys(this.$parent.$refs).length) {
      const refs = this.$parent.$refs

      for (const key in refs) {
        if (refs[key] === this) {
          refs[key] = this.$el
          break
        }
      }
    }
  },
  beforeDestroy () {
    if (Object.keys(this.$parent.$refs).length) {
      const refs = this.$parent.$refs

      for (const key in refs) {
        if (refs[key] === this.$el) {
          refs[key] = null
          break
        }
      }
    }
  }
}
</code></pre><p>注意：</p><ul><li>上述代码没有处理循环 ref，循环 ref 还需要另外判断和处理。</li></ul><h4 id="3-v-model">3. v-model</h4><h5 id="31-问题-1">3.1 问题</h5><p>我们在自定义组件中使用了渲染函数进行渲染，因此对表单组件需要额外处理 <a href="https://cn.vuejs.org/v2/guide/render-function.html#v-model">v-model</a>。</p><h5 id="32-解决方案-1">3.2 解决方案</h5><p>使用自定义组件上的 <code>model</code> 选项，定制组件使用 <code>v-model</code> 时的 prop 和 event。</p><p>改造上述的自定义组件：</p><pre><code class="language-js">export default function createFormsComponent (name, event, modelValue = &#x27;value&#x27;, classNames = []) {
  return {
    name,
    computed: {
      listeners () {
        return { ...this.$listeners }
      }
    },
    model: {
      prop: modelValue,
      event: &#x27;model&#x27;
    },
    methods: {
      input (e) {
        this.$emit(&#x27;input&#x27;, e)
        this.$emit(&#x27;model&#x27;, e.target.value)
      },
      change (e) {
        this.$emit(&#x27;change&#x27;, e)
        this.$emit(&#x27;model&#x27;, e.target.value)
      }
    },
    render (createElement) {
      return createElement(name, {
        class: [&#x27;hydrated&#x27;, ...classNames],
        on: {
          ...this.listeners,
          [event]: this[event]
        }
      }, this.$slots.default)
    }
  }
}

const Input = createFormsComponent(&#x27;taro-input&#x27;, &#x27;input&#x27;)
const Switch = createFormsComponent(&#x27;taro-switch&#x27;, &#x27;change&#x27;, &#x27;checked&#x27;)
Vue.component(&#x27;taro-input&#x27;, Input)
Vue.component(&#x27;taro-switch&#x27;, Switch)
</code></pre><h2 id="总结">总结</h2><p>当我们希望创建一些不拘泥于框架的组件时，Web Components 会是一个不错的选择。比如跨团队协作，双方的技术栈不同，但又需要公用部分组件时。</p><p>本次对 React 语法组件库进行 Web Components 化改造，工作量不下于重新搭建一个 Vue 组件库。但日后当 Taro 支持使用其他框架编写多端应用时，只需要针对对应框架与 Web Components 和 Stencil 的兼容问题编写一个胶水层即可，总体来看还是值得的。</p><p>关于胶水层，业界兼容 React 的方案颇多，只是兼容 Web Components 可以使用 <a href="https://github.com/BBKolton/reactify-wc">reactify-wc</a>，配合 Stencil 则可以使用官方提供的插件 <a href="https://github.com/ionic-team/stencil-ds-plugins/blob/master/README.md">Stencil DS Plugin</a>。倘若 Vue 需要兼容 Stencil，或需要提高兼容时的灵活性，还是建议手工编写一个胶水层。</p><p>本文简单介绍了 Taro Next、Web Components、Stencil 以及基于 Stencil 的组件库改造历程，希望能为读者们带来一些帮助与启迪。</p></section></article><div><a href="https://github.com/nervjs/taro/edit/blog/blog/2020-4-13-taro-components.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/taro/blog/2020-04-27-taro-vs-jd"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« 京东小程序 Taro 开发对比原生开发测评</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/taro/blog/2020-02-13-taro-next-alpha"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Taro Next 发布预览版：同时支持 React / Vue / Nerv »</div></a></div></nav></div></main><div class="col col--2"><div class="tableOfContents_3SO_ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#背景" class="table-of-contents__link">背景</a><ul><li><a href="#taro-next-将支持使用多框架开发" class="table-of-contents__link">Taro Next 将支持使用多框架开发</a></li><li><a href="#taro-h5" class="table-of-contents__link">Taro H5</a></li><li><a href="#方案选择" class="table-of-contents__link">方案选择</a></li></ul></li><li><a href="#web-components-简介" class="table-of-contents__link">Web Components 简介</a><ul><li><a href="#技术规范" class="table-of-contents__link">技术规范</a></li><li><a href="#示例" class="table-of-contents__link">示例</a></li></ul></li><li><a href="#stencil" class="table-of-contents__link">Stencil</a><ul><li><a href="#示例：" class="table-of-contents__link">示例：</a></li></ul></li><li><a href="#在-react-与-vue-中使用-stencil" class="table-of-contents__link">在 React 与 Vue 中使用 Stencil</a><ul><li><a href="#兼容-react" class="table-of-contents__link">兼容 React</a></li><li><a href="#兼容-vue" class="table-of-contents__link">兼容 Vue</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></div><footer class="footer" id="footer"><div class="grid_c1 footer_cont"><div class="footer_logo_container"><div class="footer_logo"></div><span class="footer_designedby"></span></div><div class="footer_link_container"><div class="footer_link"><h3 class="footer_link_tit footer_link_tit1">相关资源</h3><p><a class="link" href="https://taro.jd.com/" target="_blank">Taro</a></p><p><a class="link" href="https://taro-ui.jd.com/" target="_blank">Taro UI</a></p><p><a class="link" href="https://at-ui.github.io/at-ui/#/zh" target="_blank">At-UI</a></p><p><a class="link" href="https://nerv.aotu.io/" target="_blank">Nerv</a></p><p><a class="link" href="https://athena.aotu.io/" target="_blank">Athena</a></p></div><div class="footer_link"><h3 class="footer_link_tit footer_link_tit2">社区</h3><p><a href="https://github.com/NervJS/taro/issues" target="_blank">GitHub</a></p><p><a href="https://taro-club.jd.com" target="_blank">Taro BBS</a></p><p class="footer_link_connect_wrap"><span class="footer_link_connect footer_link_wechat">微信<span class="wechat_qrcode_icon"><svg t="1554966525626" class="icon svgicon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2588" data-spm-anchor-id="a313x.7781069.0.i0"><path d="M240.071 241.095h59.278v59.278h-59.278v-59.278z" fill="" p-id="2589"></path><path d="M405.959 134.485h-272.611v272.611h106.723v47.445h59.278v-47.445h106.723v-59.278h47.445v-47.445h-47.445l-0.114-165.888zM346.795 347.819h-154.169v-154.055h154.055v154.055h0.114zM240.071 727.154h59.278v59.278h-59.278v-59.278zM726.016 241.095h59.278v59.278h-59.278v-59.278zM512.683 509.042v63.943h59.278v-59.165h47.445v-59.278h-47.445v-47.445h-59.278v101.945zM512.683 725.789v60.643h59.278v-106.723h47.445v-59.278h-106.723v105.358zM571.961 786.432h47.445v47.445h-47.445v-47.445zM453.405 833.877v59.165h118.557v-59.165h-118.557z" fill="" p-id="2590"></path><path d="M678.685 679.709h-59.278v106.723h106.61v-59.278h-47.331v-47.445zM726.016 893.042h166.002v-59.165h-106.723v-47.445h-59.278v106.61zM892.018 513.821v-59.278h-106.723v59.278h106.723zM832.739 727.154h59.278v59.278h-59.278v-59.278zM453.405 347.819h59.278v59.278h-59.278v-59.278zM726.016 454.542v-47.445h166.002v-272.611h-272.611v59.278h-106.723v47.445h106.723v59.165h-47.445v47.445h47.445v59.278h59.278v47.445h47.331zM678.685 193.763h154.055v154.055h-154.055v-154.055zM678.685 572.985h47.331v47.445h-47.331v-47.445zM785.294 679.709h-59.278v47.445h106.723v-106.723h59.278v-47.445h-106.723v106.723zM453.405 241.095h59.278v59.278h-59.278v-59.278zM299.349 513.821h47.445v59.165h-47.445v-59.165zM453.405 454.542h-106.61v59.278h59.165v59.165h47.445v-118.443z" fill="" p-id="2591"></path><path d="M405.959 786.432v-106.723h47.445v-59.278h-213.333v-106.61h-106.723v59.278h59.278v47.445h-59.278v272.611h272.611v-59.278h47.445v-47.445h-47.445zM346.795 833.877h-154.169v-154.169h154.055v154.169h0.114zM453.405 572.985h59.278v47.445h-59.278v-47.445zM619.406 513.821h59.278v59.165h-59.278v-59.165zM726.016 513.821h59.278v59.165h-59.278v-59.165z" fill="" p-id="2592"></path></svg></span></span><span class="footer_link_wechat_img"><img src="https://camo.githubusercontent.com/10834a234b99a5880b5dff7c0ca7235e2a0772e7/687474703a2f2f696d6732302e333630627579696d672e636f6d2f7562612f6a66732f7432303139372f3238332f313638373136383837342f3133363034322f32623464383131662f35623330613635634e39643166303366312e706e67"></span></p></div><div class="footer_link"><h3 class="footer_link_tit footer_link_tit3">关于我们</h3><p><a href="https://aotu.io/" target="_blank">凹凸实验室</a></p><p><a href="https://aotu.io/join/" target="_blank">加入我们</a></p><p><a href="mailto:taro@jd.com?subject=【Taro 合作】合作标题">联系我们</a></p></div><div class="footer_link"><h3 class="footer_link_tit footer_link_tit4">感谢</h3><p><a href="http://jdc.jd.com/" target="_blank">用户体验设计部</a></p><p><a href="https://github.com/nervjs/taro#%E8%B4%A1%E7%8C%AE%E8%80%85%E4%BB%AC" target="_blank">Taro 贡献者们</a></p></div></div></div><div class="copyright"><div class="in">Copyright © 2020. All Rights Reserved. 粤ICP备15077732号-2</div></div></footer></div>
<script src="/taro/styles.55db6f27.js"></script>
<script src="/taro/runtime~main.452067a7.js"></script>
<script src="/taro/main.741ca0ab.js"></script>
<script src="/taro/1.8febc1d6.js"></script>
<script src="/taro/2.caae0f6a.js"></script>
<script src="/taro/01a85c17.d4a75056.js"></script>
<script src="/taro/18b93cb3.536e509c.js"></script>
<script src="/taro/1669.ecc950a7.js"></script>
<script src="/taro/5fc994c2.595b4ed3.js"></script>
<script src="/taro/6875c492.f9b5f9a7.js"></script>
<script src="/taro/a6aa9e1f.3e03078a.js"></script>
<script src="/taro/c42b0552.bf4bc072.js"></script>
<script src="/taro/ccc49370.da0c6a17.js"></script>
<script src="/taro/75e89b51.e14eadb4.js"></script>
<script src="/taro/3e821025.17008bdb.js"></script>
</body>
</html>